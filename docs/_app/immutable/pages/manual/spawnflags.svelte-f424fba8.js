import{S as se,i as le,s as re,F as $e,e as Q,c as x,a as M,d as a,b as J,g as i,I as oe,J as ae,K as fe,r as w,p as h,t as g,k as T,x as v,h as _,m as C,y as N,H as D,z as b,C as y,n as V}from"../../chunks/index-3d24b05e.js";import{D as Y}from"../../chunks/Divider-3642d24e.js";import{C as R,a as I}from"../../chunks/Column-fb82418a.js";import{C as me,a as ue}from"../../chunks/CardBody-c9d0a4e2.js";function ie(u){let t,n;const s=u[1].default,r=$e(s,u,u[0],null);return{c(){t=Q("div"),r&&r.c(),this.h()},l(e){t=x(e,"DIV",{class:!0});var l=M(t);r&&r.l(l),l.forEach(a),this.h()},h(){J(t,"class","my-2")},m(e,l){i(e,t,l),r&&r.m(t,null),n=!0},p(e,[l]){r&&r.p&&(!n||l&1)&&oe(r,s,e,e[0],n?fe(s,e[0],l,null):ae(e[0]),null)},i(e){n||(w(r,e),n=!0)},o(e){h(r,e),n=!1},d(e){e&&a(t),r&&r.d(e)}}}function pe(u,t,n){let{$$slots:s={},$$scope:r}=t;return u.$$set=e=>{"$$scope"in e&&n(0,r=e.$$scope)},[r,s]}class G extends se{constructor(t){super(),le(this,t,pe,ie,re,{})}}function ce(u){let t,n,s,r,e,l,f;return{c(){t=Q("h4"),n=g("Trigger Spawned Monsters"),s=g(`\r
    The most requested feature of any general purpose Quake mod is trigger spawned monsters. This makes spawning\r
    monsters much easier than in the original game. All you need to do is select the Trigger Spawn flag and target the\r
    monster with any trigger when you want them to appear. Ambush (from vanilla Quake), will prevent the selected\r
    monster from being \u201Cawakened\u201D by other monsters nearby. Errant gunfire or seeing the player will wake them up. No\r
    Sight Sound will suppress the monster\u2019s \u201Cwake up\u201D sound. (e.g. a Shambler will not roar when it sees the player.)\r
    You can make passive monsters that will never respond to the player\u2019s actions by selecting Passive always or allow\r
    them to wake up and fight with the Passive until attacked spawnflag.\r
    `),r=Q("br"),e=T(),l=Q("br"),f=g(`\r
    Starting in version 3.0.0 use the Spawn Silently flag to suppress visual and sound effects when a monster trigger\r
    spawns. In previous versions, this was enabled with the wait 1 key | value pair. This will still work but has been\r
    removed from the FGDs.`),this.h()},l(o){t=x(o,"H4",{id:!0});var S=M(t);n=_(S,"Trigger Spawned Monsters"),S.forEach(a),s=_(o,`\r
    The most requested feature of any general purpose Quake mod is trigger spawned monsters. This makes spawning\r
    monsters much easier than in the original game. All you need to do is select the Trigger Spawn flag and target the\r
    monster with any trigger when you want them to appear. Ambush (from vanilla Quake), will prevent the selected\r
    monster from being \u201Cawakened\u201D by other monsters nearby. Errant gunfire or seeing the player will wake them up. No\r
    Sight Sound will suppress the monster\u2019s \u201Cwake up\u201D sound. (e.g. a Shambler will not roar when it sees the player.)\r
    You can make passive monsters that will never respond to the player\u2019s actions by selecting Passive always or allow\r
    them to wake up and fight with the Passive until attacked spawnflag.\r
    `),r=x(o,"BR",{}),e=C(o),l=x(o,"BR",{}),f=_(o,`\r
    Starting in version 3.0.0 use the Spawn Silently flag to suppress visual and sound effects when a monster trigger\r
    spawns. In previous versions, this was enabled with the wait 1 key | value pair. This will still work but has been\r
    removed from the FGDs.`),this.h()},h(){J(t,"id","trigger-spawn")},m(o,S){i(o,t,S),D(t,n),i(o,s,S),i(o,r,S),i(o,e,S),i(o,l,S),i(o,f,S)},p:V,d(o){o&&a(t),o&&a(s),o&&a(r),o&&a(e),o&&a(l),o&&a(f)}}}function ge(u){let t;return{c(){t=g("4096")},l(n){t=_(n,"4096")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function _e(u){let t;return{c(){t=g("Not in Coop")},l(n){t=_(n,"Not in Coop")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function we(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[ge]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[_e]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function he(u){let t;return{c(){t=g("8192")},l(n){t=_(n,"8192")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function de(u){let t;return{c(){t=g("Not in Single Player")},l(n){t=_(n,"Not in Single Player")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function ve(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[he]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[de]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function Ne(u){let t;return{c(){t=g("32768")},l(n){t=_(n,"32768")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function be(u){let t;return{c(){t=g("Not on Hard Only")},l(n){t=_(n,"Not on Hard Only")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function ye(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[Ne]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[be]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function ke(u){let t;return{c(){t=g("65536")},l(n){t=_(n,"65536")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Se(u){let t;return{c(){t=g("Not on Nightmare Only")},l(n){t=_(n,"Not on Nightmare Only")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Ee(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[ke]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[Se]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function Te(u){let t;return{c(){t=g("256")},l(n){t=_(n,"256")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Ce(u){let t;return{c(){t=g("Not on Easy")},l(n){t=_(n,"Not on Easy")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function He(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[Te]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[Ce]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function Pe(u){let t;return{c(){t=g("512")},l(n){t=_(n,"512")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Oe(u){let t;return{c(){t=g("Not on Normal")},l(n){t=_(n,"Not on Normal")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Qe(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[Pe]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[Oe]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function xe(u){let t;return{c(){t=g("1024")},l(n){t=_(n,"1024")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function De(u){let t;return{c(){t=g("Not on Hard or Nightmare")},l(n){t=_(n,"Not on Hard or Nightmare")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Ae(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[xe]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[De]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function Ie(u){let t;return{c(){t=g("2048")},l(n){t=_(n,"2048")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Me(u){let t;return{c(){t=g("Not in Deathmatch")},l(n){t=_(n,"Not in Deathmatch")},m(n,s){i(n,t,s)},d(n){n&&a(t)}}}function Be(u){let t,n,s,r;return t=new I({props:{col:"1",classes:"text-right",$$slots:{default:[Ie]},$$scope:{ctx:u}}}),s=new I({props:{col:"11",$$slots:{default:[Me]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment)},l(e){N(t.$$.fragment,e),n=C(e),N(s.$$.fragment,e)},m(e,l){b(t,e,l),i(e,n,l),b(s,e,l),r=!0},p(e,l){const f={};l&1&&(f.$$scope={dirty:l,ctx:e}),t.$set(f);const o={};l&1&&(o.$$scope={dirty:l,ctx:e}),s.$set(o)},i(e){r||(w(t.$$.fragment,e),w(s.$$.fragment,e),r=!0)},o(e){h(t.$$.fragment,e),h(s.$$.fragment,e),r=!1},d(e){y(t,e),e&&a(n),y(s,e)}}}function Fe(u){let t,n,s,r,e,l,f,o,S,E,H,O,k,m,d,c,P,A,q,B,z,F,K,j;return r=new R({props:{$$slots:{default:[we]},$$scope:{ctx:u}}}),l=new R({props:{$$slots:{default:[ve]},$$scope:{ctx:u}}}),o=new R({props:{$$slots:{default:[ye]},$$scope:{ctx:u}}}),E=new R({props:{$$slots:{default:[Ee]},$$scope:{ctx:u}}}),c=new R({props:{$$slots:{default:[He]},$$scope:{ctx:u}}}),A=new R({props:{$$slots:{default:[Qe]},$$scope:{ctx:u}}}),B=new R({props:{$$slots:{default:[Ae]},$$scope:{ctx:u}}}),F=new R({props:{$$slots:{default:[Be]},$$scope:{ctx:u}}}),{c(){t=Q("h4"),n=g("Appearance Flags"),s=g(`\r
    Nearly every entity in the devkit has an expanded set of \u201CAppearflags\u201D compared to vanilla Quake. These new flags\r
    allow you to customize what shows up in a specific mode of the game.\r
\r
    `),v(r.$$.fragment),e=T(),v(l.$$.fragment),f=T(),v(o.$$.fragment),S=T(),v(E.$$.fragment),H=g(`\r
    Spawnflag 16384 is not used here because it's already used for something else in progs_dump.\r
    `),O=Q("br"),k=T(),m=Q("br"),d=g(`\r
\r
    The new spawnflags complement and complete the set of built-in spawnflags provided by the engine, which of course\r
    are:\r
\r
    `),v(c.$$.fragment),P=T(),v(A.$$.fragment),q=T(),v(B.$$.fragment),z=T(),v(F.$$.fragment),K=g(`\r
\r
\r
    In conjunction with the old spawnflags, the new spawnflags make it possible to exclude any entity from any\r
    combination of game modes and/or skill levels.`),this.h()},l($){t=x($,"H4",{id:!0});var p=M(t);n=_(p,"Appearance Flags"),p.forEach(a),s=_($,`\r
    Nearly every entity in the devkit has an expanded set of \u201CAppearflags\u201D compared to vanilla Quake. These new flags\r
    allow you to customize what shows up in a specific mode of the game.\r
\r
    `),N(r.$$.fragment,$),e=C($),N(l.$$.fragment,$),f=C($),N(o.$$.fragment,$),S=C($),N(E.$$.fragment,$),H=_($,`\r
    Spawnflag 16384 is not used here because it's already used for something else in progs_dump.\r
    `),O=x($,"BR",{}),k=C($),m=x($,"BR",{}),d=_($,`\r
\r
    The new spawnflags complement and complete the set of built-in spawnflags provided by the engine, which of course\r
    are:\r
\r
    `),N(c.$$.fragment,$),P=C($),N(A.$$.fragment,$),q=C($),N(B.$$.fragment,$),z=C($),N(F.$$.fragment,$),K=_($,`\r
\r
\r
    In conjunction with the old spawnflags, the new spawnflags make it possible to exclude any entity from any\r
    combination of game modes and/or skill levels.`),this.h()},h(){J(t,"id","appearance-flags")},m($,p){i($,t,p),D(t,n),i($,s,p),b(r,$,p),i($,e,p),b(l,$,p),i($,f,p),b(o,$,p),i($,S,p),b(E,$,p),i($,H,p),i($,O,p),i($,k,p),i($,m,p),i($,d,p),b(c,$,p),i($,P,p),b(A,$,p),i($,q,p),b(B,$,p),i($,z,p),b(F,$,p),i($,K,p),j=!0},p($,p){const L={};p&1&&(L.$$scope={dirty:p,ctx:$}),r.$set(L);const U={};p&1&&(U.$$scope={dirty:p,ctx:$}),l.$set(U);const W={};p&1&&(W.$$scope={dirty:p,ctx:$}),o.$set(W);const X={};p&1&&(X.$$scope={dirty:p,ctx:$}),E.$set(X);const Z={};p&1&&(Z.$$scope={dirty:p,ctx:$}),c.$set(Z);const ee={};p&1&&(ee.$$scope={dirty:p,ctx:$}),A.$set(ee);const te={};p&1&&(te.$$scope={dirty:p,ctx:$}),B.$set(te);const ne={};p&1&&(ne.$$scope={dirty:p,ctx:$}),F.$set(ne)},i($){j||(w(r.$$.fragment,$),w(l.$$.fragment,$),w(o.$$.fragment,$),w(E.$$.fragment,$),w(c.$$.fragment,$),w(A.$$.fragment,$),w(B.$$.fragment,$),w(F.$$.fragment,$),j=!0)},o($){h(r.$$.fragment,$),h(l.$$.fragment,$),h(o.$$.fragment,$),h(E.$$.fragment,$),h(c.$$.fragment,$),h(A.$$.fragment,$),h(B.$$.fragment,$),h(F.$$.fragment,$),j=!1},d($){$&&a(t),$&&a(s),y(r,$),$&&a(e),y(l,$),$&&a(f),y(o,$),$&&a(S),y(E,$),$&&a(H),$&&a(O),$&&a(k),$&&a(m),$&&a(d),y(c,$),$&&a(P),y(A,$),$&&a(q),y(B,$),$&&a(z),y(F,$),$&&a(K)}}}function Re(u){let t,n,s,r,e,l,f,o,S,E,H,O;return{c(){t=Q("h5"),n=Q("em"),s=g("Not in Coop"),r=g(" and "),e=Q("em"),l=g("Not in Single Player"),f=T(),o=Q("p"),S=g(`These spawnflags were inspired by Quoth 2 (Kell and Necros, 2008), which included two additional spawnflags for\r
        all entities: Not in Coop and Coop Only.`),E=T(),H=Q("p"),O=g(`In contrast to Quoth 2, the spawnflags implemented here are Not in Coop and Not in Single Player, for symmetry\r
        with the built-in Not in Deathmatch spawnflag.`)},l(k){t=x(k,"H5",{});var m=M(t);n=x(m,"EM",{});var d=M(n);s=_(d,"Not in Coop"),d.forEach(a),r=_(m," and "),e=x(m,"EM",{});var c=M(e);l=_(c,"Not in Single Player"),c.forEach(a),m.forEach(a),f=C(k),o=x(k,"P",{});var P=M(o);S=_(P,`These spawnflags were inspired by Quoth 2 (Kell and Necros, 2008), which included two additional spawnflags for\r
        all entities: Not in Coop and Coop Only.`),P.forEach(a),E=C(k),H=x(k,"P",{});var A=M(H);O=_(A,`In contrast to Quoth 2, the spawnflags implemented here are Not in Coop and Not in Single Player, for symmetry\r
        with the built-in Not in Deathmatch spawnflag.`),A.forEach(a)},m(k,m){i(k,t,m),D(t,n),D(n,s),D(t,r),D(t,e),D(e,l),i(k,f,m),i(k,o,m),D(o,S),i(k,E,m),i(k,H,m),D(H,O)},p:V,d(k){k&&a(t),k&&a(f),k&&a(o),k&&a(E),k&&a(H)}}}function qe(u){let t,n,s,r,e,l,f,o,S,E,H,O,k,m,d;return{c(){t=Q("h5"),n=Q("em"),s=g("Not on Hard Only"),r=g(" and "),e=Q("em"),l=g("Not on Nightmare Only"),f=T(),o=Q("p"),S=g(`The set of built-in spawnflags doesn't allow a mapper to treat the Hard and Nightmare skill levels differently,\r
        because it only includes one spawnflag, 1024, which excludes an entity from both Hard and Nightmare.`),E=T(),H=Q("p"),O=g(`The new Not on Hard Only and Not on Nightmare Only spawnflags allow the mapper to exclude an entity from one of\r
        these skill levels without affecting the other.`),k=T(),m=Q("p"),d=g("The original spawnflag will supersede the new flags.")},l(c){t=x(c,"H5",{});var P=M(t);n=x(P,"EM",{});var A=M(n);s=_(A,"Not on Hard Only"),A.forEach(a),r=_(P," and "),e=x(P,"EM",{});var q=M(e);l=_(q,"Not on Nightmare Only"),q.forEach(a),P.forEach(a),f=C(c),o=x(c,"P",{});var B=M(o);S=_(B,`The set of built-in spawnflags doesn't allow a mapper to treat the Hard and Nightmare skill levels differently,\r
        because it only includes one spawnflag, 1024, which excludes an entity from both Hard and Nightmare.`),B.forEach(a),E=C(c),H=x(c,"P",{});var z=M(H);O=_(z,`The new Not on Hard Only and Not on Nightmare Only spawnflags allow the mapper to exclude an entity from one of\r
        these skill levels without affecting the other.`),z.forEach(a),k=C(c),m=x(c,"P",{});var F=M(m);d=_(F,"The original spawnflag will supersede the new flags."),F.forEach(a)},m(c,P){i(c,t,P),D(t,n),D(n,s),D(t,r),D(t,e),D(e,l),i(c,f,P),i(c,o,P),D(o,S),i(c,E,P),i(c,H,P),D(H,O),i(c,k,P),i(c,m,P),D(m,d)},p:V,d(c){c&&a(t),c&&a(f),c&&a(o),c&&a(E),c&&a(H),c&&a(k),c&&a(m)}}}function ze(u){let t,n,s,r,e,l;return t=new G({props:{$$slots:{default:[Re]},$$scope:{ctx:u}}}),s=new Y({}),e=new G({props:{$$slots:{default:[qe]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment),n=T(),v(s.$$.fragment),r=T(),v(e.$$.fragment)},l(f){N(t.$$.fragment,f),n=C(f),N(s.$$.fragment,f),r=C(f),N(e.$$.fragment,f)},m(f,o){b(t,f,o),i(f,n,o),b(s,f,o),i(f,r,o),b(e,f,o),l=!0},p(f,o){const S={};o&1&&(S.$$scope={dirty:o,ctx:f}),t.$set(S);const E={};o&1&&(E.$$scope={dirty:o,ctx:f}),e.$set(E)},i(f){l||(w(t.$$.fragment,f),w(s.$$.fragment,f),w(e.$$.fragment,f),l=!0)},o(f){h(t.$$.fragment,f),h(s.$$.fragment,f),h(e.$$.fragment,f),l=!1},d(f){y(t,f),f&&a(n),y(s,f),f&&a(r),y(e,f)}}}function Ke(u){let t,n;return t=new ue({props:{$$slots:{default:[ze]},$$scope:{ctx:u}}}),{c(){v(t.$$.fragment)},l(s){N(t.$$.fragment,s)},m(s,r){b(t,s,r),n=!0},p(s,r){const e={};r&1&&(e.$$scope={dirty:r,ctx:s}),t.$set(e)},i(s){n||(w(t.$$.fragment,s),n=!0)},o(s){h(t.$$.fragment,s),n=!1},d(s){y(t,s)}}}function je(u){let t,n,s,r,e,l,f,o,S,E,H,O,k;return r=new Y({}),l=new G({props:{$$slots:{default:[ce]},$$scope:{ctx:u}}}),o=new Y({}),E=new G({props:{$$slots:{default:[Fe]},$$scope:{ctx:u}}}),O=new me({props:{$$slots:{default:[Ke]},$$scope:{ctx:u}}}),{c(){t=Q("h1"),n=g("Spawnflags"),s=T(),v(r.$$.fragment),e=T(),v(l.$$.fragment),f=T(),v(o.$$.fragment),S=T(),v(E.$$.fragment),H=T(),v(O.$$.fragment)},l(m){t=x(m,"H1",{});var d=M(t);n=_(d,"Spawnflags"),d.forEach(a),s=C(m),N(r.$$.fragment,m),e=C(m),N(l.$$.fragment,m),f=C(m),N(o.$$.fragment,m),S=C(m),N(E.$$.fragment,m),H=C(m),N(O.$$.fragment,m)},m(m,d){i(m,t,d),D(t,n),i(m,s,d),b(r,m,d),i(m,e,d),b(l,m,d),i(m,f,d),b(o,m,d),i(m,S,d),b(E,m,d),i(m,H,d),b(O,m,d),k=!0},p(m,[d]){const c={};d&1&&(c.$$scope={dirty:d,ctx:m}),l.$set(c);const P={};d&1&&(P.$$scope={dirty:d,ctx:m}),E.$set(P);const A={};d&1&&(A.$$scope={dirty:d,ctx:m}),O.$set(A)},i(m){k||(w(r.$$.fragment,m),w(l.$$.fragment,m),w(o.$$.fragment,m),w(E.$$.fragment,m),w(O.$$.fragment,m),k=!0)},o(m){h(r.$$.fragment,m),h(l.$$.fragment,m),h(o.$$.fragment,m),h(E.$$.fragment,m),h(O.$$.fragment,m),k=!1},d(m){m&&a(t),m&&a(s),y(r,m),m&&a(e),y(l,m),m&&a(f),y(o,m),m&&a(S),y(E,m),m&&a(H),y(O,m)}}}class Le extends se{constructor(t){super(),le(this,t,null,je,re,{})}}export{Le as default};
